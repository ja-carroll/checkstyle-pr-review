package github

import (
	"checkstyle-review/comment"
	"checkstyle-review/github/util"
	"context"
	"fmt"
	"log"
	"path/filepath"
	"strings"

	"github.com/google/go-github/v64/github"
)

// PullRequest is a comment and diff service for GitHub PullRequest.
//
// API:
//
//	https://docs.github.com/en/rest/pulls/comments?apiVersion=2022-11-28#create-a-review-comment-for-a-pull-request
//	POST /repos/:owner/:repo/pulls/:number/comments
type PullRequest struct {
	cli              *github.Client
	owner            string
	repo             string
	pr               int
	sha              string
	FallBackToGitCLI bool

	// wd is working directory relative to root of repository.
	wd string
}

const maxCommentsPerRequest = 30

// NewGitHubPullRequest returns a new PullRequest service.
//
// The GitHub Token generated by GitHub Actions may not have the necessary permissions.
// For example, in the case of a PR from a forked repository, or when write permission is prohibited in the repository settings [1].
//
// In such a case, the service will fallback to GitHub Actions workflow commands [2].
//
// [1]: https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
// [2]: https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions
func NewGitHubPullRequest(cli *github.Client, owner, repo string, pr int, sha string) (*PullRequest, error) {
	workDir, err := util.GitRelWorkdir()
	if err != nil {
		return nil, err
	}
	return &PullRequest{
		cli:   cli,
		owner: owner,
		repo:  repo,
		pr:    pr,
		sha:   sha,
		wd:    workDir,
	}, nil
}

func (g *PullRequest) PostAsReviewComment(ctx context.Context, postComments []*comment.Comment) error {

	reviewComments := make([]*github.DraftReviewComment, 0, len(postComments))
	remaining := make([]*comment.Comment, 0)
	rootPath, err := util.GetGitRoot()
	if err != nil {
		return err
	}
	repoBaseHTMLURL, err := g.repoBaseHTMLURL(ctx)
	if err != nil {
		return err
	}
	for _, c := range postComments {

		// Only posts maxCommentsPerRequest comments per 1 request to avoid spammy
		// review comments. An example GitHub error if we don't limit the # of
		// review comments.
		//
		// > 403 You have triggered an abuse detection mechanism and have been
		// > temporarily blocked from content creation. Please retry your request
		// > again later.
		// https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#rate-limiting
		if len(reviewComments) >= maxCommentsPerRequest {
			remaining = append(remaining, c)
			continue
		}
		comment := buildDraftReviewComment(c, buildBody(c, repoBaseHTMLURL, rootPath))
		reviewComments = append(reviewComments, comment)

	}

	if len(reviewComments) > 0 || len(remaining) > 0 {
		// send review comments to GitHub.
		review := &github.PullRequestReviewRequest{
			CommitID: &g.sha,
			Event:    github.String("COMMENT"),
			Comments: reviewComments,
			Body:     github.String(g.remainingCommentsSummary(remaining, repoBaseHTMLURL, rootPath)),
		}
		_, _, err := g.cli.PullRequests.CreateReview(ctx, g.owner, g.repo, g.pr, review)
		if err != nil {
			log.Printf("Failed to post a review comment: %v", err)
			// GitHub returns 403 or 404 if we don't have permission to post a review comment.
			// fallback to log message in this case.
			return err
		}
	}

	return nil

}

// Document: https://docs.github.com/en/rest/reference/pulls#create-a-review-comment-for-a-pull-request
func buildDraftReviewComment(c *comment.Comment, body string) *github.DraftReviewComment {
	startLine, endLine := githubCommentLineRange(c)
	r := &github.DraftReviewComment{
		Path: github.String(c.Result.File),
		Side: github.String("RIGHT"),
		Body: github.String(body),
		Line: github.Int(endLine),
	}
	// GitHub API: Start line must precede the end line.
	if startLine < endLine {
		r.StartSide = github.String("RIGHT")
		r.StartLine = github.Int(startLine)
	}
	return r
}

func githubCommentLineRange(c *comment.Comment) (start int, end int) {
	startLine := c.Result.Line
	endLine := 0
	endLine = startLine
	return startLine, endLine
}

func (g *PullRequest) remainingCommentsSummary(remaining []*comment.Comment, baseURL string, gitRootPath string) string {
	if len(remaining) == 0 {
		return ""
	}
	perTool := make(map[string][]*comment.Comment)
	for _, c := range remaining {
		perTool[c.ToolName] = append(perTool[c.ToolName], c)
	}
	var sb strings.Builder
	sb.WriteString("Remaining comments which cannot be posted as a review comment to avoid GitHub Rate Limit\n")
	sb.WriteString("\n")
	for tool, comments := range perTool {
		sb.WriteString("<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>%s</summary>\n", tool))
		sb.WriteString("\n")
		for _, c := range comments {
			sb.WriteString("<hr>")
			sb.WriteString("\n")
			sb.WriteString("\n")
			sb.WriteString(comment.MarkdownComment(c))
			sb.WriteString("\n")
			sb.WriteString("\n")
			sb.WriteString(githubCodeSnippetURL(baseURL, gitRootPath, c.Result.File, c.Result.Line))
			sb.WriteString("\n")
			sb.WriteString("\n")
		}
		sb.WriteString("</details>\n")
	}
	return sb.String()
}

// Strip returns 1 as a strip of git diff.
func (g *PullRequest) Strip() int {
	return 1
}

func (g *PullRequest) repoBaseHTMLURL(ctx context.Context) (string, error) {
	repo, _, err := g.cli.Repositories.Get(ctx, g.owner, g.repo)
	if err != nil {
		return "", fmt.Errorf("failed to build repo base HTML URL: %w", err)
	}
	return repo.GetHTMLURL() + "/blob/" + g.sha, nil
}

func (g *PullRequest) comment(ctx context.Context) ([]*github.PullRequestComment, error) {
	// https://developer.github.com/v3/guides/traversing-with-pagination/
	opts := &github.PullRequestListCommentsOptions{
		ListOptions: github.ListOptions{
			PerPage: 100,
		},
	}
	comments, err := listAllPullRequestsComments(ctx, g.cli, g.owner, g.repo, g.pr, opts)
	if err != nil {
		return nil, err
	}
	return comments, nil
}

func listAllPullRequestsComments(ctx context.Context, cli *github.Client,
	owner, repo string, pr int, opts *github.PullRequestListCommentsOptions) ([]*github.PullRequestComment, error) {
	comments, resp, err := cli.PullRequests.ListComments(ctx, owner, repo, pr, opts)
	if err != nil {
		return nil, err
	}
	if resp.NextPage == 0 {
		return comments, nil
	}
	newOpts := &github.PullRequestListCommentsOptions{
		ListOptions: github.ListOptions{
			Page:    resp.NextPage,
			PerPage: opts.PerPage,
		},
	}
	restComments, err := listAllPullRequestsComments(ctx, cli, owner, repo, pr, newOpts)
	if err != nil {
		return nil, err
	}
	return append(comments, restComments...), nil
}

func buildBody(c *comment.Comment, baseURL string, gitRootPath string) string {
	cbody := comment.MarkdownComment(c)
	if c.Result.Line > 0 {
		snippetURL := githubCodeSnippetURL(baseURL, gitRootPath, c.Result.File, c.Result.Line)
		cbody += "\n\n" + snippetURL
	}
	return cbody
}

func githubCodeSnippetURL(baseURL, gitRootPath string, location string, start int) string {
	relPath := NormalizePath(location, gitRootPath, "")
	relatedURL := fmt.Sprintf("%s/%s", baseURL, relPath)
	if startLine := start; startLine > 0 {
		relatedURL += fmt.Sprintf("#L%d", startLine)
	}
	return relatedURL
}

// NormalizePath return normalized path with workdir and relative path to
// project.
func NormalizePath(path, workdir, projectRelPath string) string {
	path = filepath.Clean(path)
	if path == "." {
		return ""
	}
	// Convert absolute path to relative path only if the path is in current
	// directory.
	if filepath.IsAbs(path) && workdir != "" && contains(path, workdir) {
		relPath, err := filepath.Rel(workdir, path)
		if err == nil {
			path = relPath
		}
	}
	if !filepath.IsAbs(path) && projectRelPath != "" {
		path = filepath.Join(projectRelPath, path)
	}
	return filepath.ToSlash(path)
}

func contains(path, base string) bool {
	ps := splitPathList(path)
	bs := splitPathList(base)
	if len(ps) < len(bs) {
		return false
	}
	for i := range bs {
		if bs[i] != ps[i] {
			return false
		}
	}
	return true
}

func splitPathList(path string) []string {
	return strings.Split(filepath.ToSlash(path), "/")
}
